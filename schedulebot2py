import asyncio
import json
import logging
import os
from datetime import datetime, timedelta, time
from pathlib import Path

import pytz
from dotenv import load_dotenv
from telegram import Bot
from telegram.constants import ParseMode

# ================== INIT ==================
load_dotenv()
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")

BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
SCHEDULE_FILE = Path(os.getenv("SCHEDULE_FILE", "schedule.json"))
SCHEDULE_TOMORROW_FILE = Path(os.getenv("SCHEDULE_TOMORROW_FILE", "schedule_tomorrow.json"))
STATE_FILE = Path("bot_state.json")
TIMEZONE = pytz.timezone(os.getenv("TIMEZONE", "Europe/Kyiv"))

bot = Bot(token=BOT_TOKEN)

last_schedule_mtime = None
last_schedule_tomorrow_mtime = None
current_schedule = {}
current_schedule_tomorrow = {}
scheduled_tasks: list[asyncio.Task] = []

# ================== STATE ==================
def load_state():
    if STATE_FILE.exists():
        try:
            with open(STATE_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return {}
    return {}


def save_state(state):
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f, ensure_ascii=False, indent=2)


def cleanup_state(state, days: int = 10):
    cutoff = datetime.now() - timedelta(days=days)
    new_state = {}
    for key, value in state.items():
        try:
            dt = datetime.strptime(key.split("_")[-1], "%Y-%m-%d_%H:%M")
            if dt > cutoff:
                new_state[key] = value
        except Exception:
            new_state[key] = value
    if len(new_state) != len(state):
        save_state(new_state)
        logging.info("üßπ –û—á–∏—â–µ–Ω–æ —Å—Ç–∞—Ä—ñ –∑–∞–ø–∏—Å–∏ –∑—ñ —Å—Ç–∞–Ω—É (—Å—Ç–∞—Ä—à–µ %d –¥—ñ–±)", days)
    return new_state


bot_state = cleanup_state(load_state())

# ================== HELPERS ==================
def local_now() -> datetime:
    return datetime.now(TIMEZONE)


def day_timestr_to_datetime(timestr: str, day_offset: int = 0) -> datetime:
    now = local_now()
    hour, minute = map(int, timestr.split(":"))
    date = now.date() + timedelta(days=day_offset)
    return TIMEZONE.localize(datetime.combine(date, time(hour, minute)))


def load_json_file(file_path: Path) -> dict:
    if not file_path.exists():
        return {}
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        logging.error("‚ùå –ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è %s: %s", file_path, e)
        return {}


def load_schedules() -> tuple[dict, dict, bool]:
    global last_schedule_mtime, last_schedule_tomorrow_mtime, current_schedule, current_schedule_tomorrow

    changed = False

    if SCHEDULE_FILE.exists():
        mtime = SCHEDULE_FILE.stat().st_mtime
        if last_schedule_mtime is None or mtime != last_schedule_mtime:
            last_schedule_mtime = mtime
            current_schedule = load_json_file(SCHEDULE_FILE)
            logging.info("üîÅ –û–Ω–æ–≤–ª–µ–Ω–æ schedule.json")
            changed = True

    if SCHEDULE_TOMORROW_FILE.exists():
        mtime_t = SCHEDULE_TOMORROW_FILE.stat().st_mtime
        if last_schedule_tomorrow_mtime is None or mtime_t != last_schedule_tomorrow_mtime:
            last_schedule_tomorrow_mtime = mtime_t
            current_schedule_tomorrow = load_json_file(SCHEDULE_TOMORROW_FILE)
            logging.info("üîÅ –û–Ω–æ–≤–ª–µ–Ω–æ schedule_tomorrow.json")
            changed = True
    else:
        if current_schedule_tomorrow:
            current_schedule_tomorrow = {}
            changed = True

    return current_schedule, current_schedule_tomorrow, changed


def schedule_task(coro):
    task = asyncio.create_task(coro)
    scheduled_tasks.append(task)
    return task


def cancel_all_scheduled_tasks():
    alive = 0
    for t in scheduled_tasks:
        if not t.done():
            t.cancel()
            alive += 1
    scheduled_tasks.clear()
    if alive:
        logging.info("üõë –°–∫–∞—Å–æ–≤–∞–Ω–æ %d –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ—Ö –∑–∞–¥–∞—á(—ñ).", alive)


# ================== SCHEDULER ==================
async def schedule_tasks_for(schedule: dict, day_offset: int = 0):
    now = local_now()
    date_str = "—Å—å–æ–≥–æ–¥–Ω—ñ" if day_offset == 0 else "–∑–∞–≤—Ç—Ä–∞"
    logging.info("üìÖ –ü–ª–∞–Ω—É–≤–∞–Ω–Ω—è –ø–æ—Å—Ç—ñ–≤ –Ω–∞ %s...", date_str)

    for friendly_name, data in schedule.items():
        if not isinstance(data, dict):
            continue
        channel = data.get("channel_id")
        if not channel:
            continue
        periods = data.get("periods", [])

        for i, (start_str, end_str) in enumerate(periods):
            start_dt = day_timestr_to_datetime(start_str, day_offset)
            end_dt = day_timestr_to_datetime(end_str, day_offset)

            # –ü–µ—Ä–µ—Ö—ñ–¥ —á–µ—Ä–µ–∑ –ø—ñ–≤–Ω—ñ—á
            if end_dt <= start_dt:
                end_dt += timedelta(days=1)

            # ‚è≥ –ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –∑–∞ 5 —Ö–≤ –¥–æ –ø–æ—á–∞—Ç–∫—É
            pre_dt = start_dt - timedelta(minutes=5)

            # –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ –ø–æ–¥—ñ—ó, —â–æ –≤–∂–µ –º–∏–Ω—É–ª–∏ –ø–æ–≤–Ω—ñ—Å—Ç—é
            if end_dt < now:
                continue

            # ---- PRE-NOTICE (if —â–µ –Ω–µ –º–∏–Ω—É–ª–æ) ----
            if pre_dt > now:
                pre_text = (
                    f"‚è≥ –ß–µ—Ä–µ–∑ 5 —Ö–≤ –≤–∏–º–∫–Ω–µ–Ω–Ω—è –∑ {start_dt.strftime('%H:%M')} –¥–æ {end_dt.strftime('%H:%M')}."
                    
                )
                schedule_task(
                    maybe_post_message(
                        channel,
                        friendly_name,
                        pre_text,
                        pre_dt,
                        f"pre_{day_offset}",
                    )
                )

            # ---- START (OFF) ----
            off_text = (
                f"üî¥ –í–ò–ú–ö–ù–ï–ù–ù–Ø –∑ {start_dt.strftime('%H:%M')} –¥–æ üí°{end_dt.strftime('%H:%M')}."
            )
            schedule_task(
                maybe_post_message(
                    channel,
                    friendly_name,
                    off_text,
                    start_dt,
                    f"off_{day_offset}",
                )
            )

            # ---- END (ON) ----
            next_off = periods[i + 1][0] if i + 1 < len(periods) else None
            on_text = f"‚ö° –°–í–Ü–¢–õ–û –£–í–Ü–ú–ö–ù–ï–ù–û –æ {end_dt.strftime('%H:%M')}."
            if next_off:
                on_text += f"\nüî¥ –ù–∞—Å—Ç—É–ø–Ω–µ –≤–∏–º–∫–Ω–µ–Ω–Ω—è –æ {next_off}"

            schedule_task(
                maybe_post_message(
                    channel,
                    friendly_name,
                    on_text,
                    end_dt,
                    f"on_{day_offset}",
                )
            )

    logging.info("‚úÖ –ó–∞–¥–∞—á—ñ –Ω–∞ %s —Å—Ç–≤–æ—Ä–µ–Ω–æ.", date_str)


async def maybe_post_message(channel_id, friendly_name, text, send_time, event_type):
    delay = (send_time - local_now()).total_seconds()
    if delay > 0:
        try:
            await asyncio.sleep(delay)
        except asyncio.CancelledError:
            return

    key = f"{friendly_name}_{event_type}_{send_time.strftime('%Y-%m-%d_%H:%M')}"
    if bot_state.get(key):
        logging.info("‚è© –ü—Ä–æ–ø—É—â–µ–Ω–æ –¥—É–±–ª—å–æ–≤–∞–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: %s", key)
        return

    await post_message(channel_id, text)
    bot_state[key] = True
    save_state(bot_state)


async def post_message(channel_id, text):
    try:
        await bot.send_message(chat_id=channel_id, text=text, parse_mode=ParseMode.HTML)
        logging.info("üì§ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ —É %s", channel_id)
    except Exception as e:
        logging.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—ñ —É %s: %s", channel_id, e)


# ================== MAIN ==================
async def main():
    logging.info("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω–æ.")

    schedule, schedule_tomorrow, _ = load_schedules()
    await schedule_tasks_for(schedule, 0)
    if schedule_tomorrow:
        await schedule_tasks_for(schedule_tomorrow, 1)

    def next_midnight(dt: datetime) -> datetime:
        return (dt + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)

    rollover_at = next_midnight(local_now())

    while True:
        await asyncio.sleep(60)
        schedule, schedule_tomorrow, changed = load_schedules()
        now = local_now()

        if changed:
            cancel_all_scheduled_tasks()
            await schedule_tasks_for(schedule, 0)
            if schedule_tomorrow:
                await schedule_tasks_for(schedule_tomorrow, 1)
            rollover_at = next_midnight(now)
            continue

        if now >= rollover_at:
            cancel_all_scheduled_tasks()
            if SCHEDULE_TOMORROW_FILE.exists():
                try:
                    os.remove(SCHEDULE_TOMORROW_FILE)
                    logging.info("üóëÔ∏è –í–∏–¥–∞–ª–µ–Ω–æ schedule_tomorrow.json –ø—ñ—Å–ª—è –æ–ø—ñ–≤–Ω–æ—á—ñ.")
                except Exception as e:
                    logging.error("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –≤–∏–¥–∞–ª–∏—Ç–∏ schedule_tomorrow.json: %s", e)
            await schedule_tasks_for(schedule, 0)
            schedule, schedule_tomorrow, _ = load_schedules()
            if schedule_tomorrow:
                await schedule_tasks_for(schedule_tomorrow, 1)
            rollover_at = next_midnight(now)


if __name__ == "__main__":
    asyncio.run(main())
